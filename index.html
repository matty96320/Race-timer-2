<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enduro Race Timer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            color: #374151;
        }
        .container {
            max-width: 1200px;
        }
        .card {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 2rem;
        }
        .button {
            transition: transform 0.1s ease-in-out, box-shadow 0.1s ease-in-out;
        }
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4 sm:p-8 flex flex-col items-center">

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setDoc, updateDoc, collection, getDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        let app, db, auth;
        let raceData = { riders: [], stages: 6 };
        let raceUnsubscribe = null, timersUnsubscribe = null;
        let currentRaceId = null, currentTimingStage = null;
        let activeTimers = {};
        
        let raceIdInput, loadRaceBtn, newRaceBtn, raceInfoDiv, raceTimerContainer;
        let riderForm, ridersTableBody, resultsTableBody, riderCountDisplay;
        let startTimerBtn, timingRiderInput, messageBox, activeTimersList, stageCountInput, exportCsvBtn;
        let stageSelectionContainer, timingStationSelect, startTimingStationBtn, timingStationActive, timingStationHeader, switchStageBtn;
        let stageStandingsHeader, stageStandingsBody, currentOverallStandingsBody;
        let riderManagementSection;

        const showMessage = (message, isError = false) => {
            if (!messageBox) return;
            messageBox.textContent = message;
            messageBox.className = `p-3 rounded-md text-center font-semibold mb-4 transition-all duration-300 ${isError ? 'bg-red-500 text-white' : 'bg-green-500 text-white'}`;
            messageBox.classList.remove('opacity-0', 'scale-95');
            messageBox.classList.add('opacity-100', 'scale-100');
            setTimeout(() => {
                messageBox.classList.remove('opacity-100', 'scale-100');
                messageBox.classList.add('opacity-0', 'scale-95');
            }, 3000);
        };

        const setupRaceListener = (raceId) => {
            if (raceUnsubscribe) raceUnsubscribe();
            currentRaceId = raceId;
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'enduro-timer-default';
            const raceDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'races', raceId);
            raceUnsubscribe = onSnapshot(raceDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    raceData = docSnap.data();
                    if (!raceData.riders) raceData.riders = []; 
                    if(currentTimingStage === null) {
                       showStageSelection();
                    }
                    renderRaceData();
                    populateTimingDropdown();
                } else {
                    raceData = { riders: [], stages: raceData.stages || 6, raceId: raceId };
                    setDoc(raceDocRef, raceData);
                }
            }, (error) => console.error("Error listening for real-time updates: ", error));
            setupTimersListener(raceId);
        };
        
        const setupTimersListener = (raceId) => {
            if (timersUnsubscribe) timersUnsubscribe();
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'enduro-timer-default';
            const timersCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'races', raceId, 'timers');
            timersUnsubscribe = onSnapshot(timersCollectionRef, (querySnapshot) => {
                activeTimers = {};
                querySnapshot.forEach((doc) => {
                    activeTimers[doc.id] = { ...doc.data(), id: doc.id };
                });
                renderActiveTimers();
            }, (error) => console.error("Error listening for active timers: ", error));
        };

        const renderActiveTimers = () => {
            if (!activeTimersList || currentTimingStage === null) return;
            activeTimersList.innerHTML = '';
            const stageTimers = Object.values(activeTimers).filter(timer => timer.stageIndex === currentTimingStage);
            if (stageTimers.length === 0) {
                activeTimersList.innerHTML = `<li class="text-sm text-gray-500">No active timers for this stage.</li>`;
            } else {
                stageTimers.forEach(timer => {
                    const elapsed = Math.floor((Date.now() - timer.startTime) / 1000);
                    const timeString = formatTime(elapsed);
                    const rider = raceData.riders.find(r => r.number === timer.riderNumber);
                    const riderDetails = rider ? `(${rider.name}${rider.category ? ', ' + rider.category : ''})` : '';
                    const listItem = document.createElement('li');
                    listItem.className = "flex justify-between items-center p-2 bg-gray-100 rounded-md shadow-sm";
                    listItem.innerHTML = `<span>Rider #${timer.riderNumber} ${riderDetails} : ${timeString}</span>`;
                    const stopButton = document.createElement('button');
                    stopButton.textContent = 'Stop';
                    stopButton.className = 'button px-3 py-1 bg-red-600 text-white text-sm font-bold rounded-md shadow-sm hover:bg-red-700';
                    stopButton.onclick = () => stopSpecificTimer(timer.riderNumber, timer.stageIndex);
                    listItem.appendChild(stopButton);
                    activeTimersList.appendChild(listItem);
                });
            }
        };

        const stopSpecificTimer = async (riderNumber, stageIndex) => {
            const timerDocId = `${riderNumber}-${stageIndex}`;
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'enduro-timer-default';
            const timerDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'races', currentRaceId, 'timers', timerDocId);
            try {
                const docSnap = await getDoc(timerDocRef);
                if (docSnap.exists()) {
                    const timerData = docSnap.data();
                    const elapsedSeconds = Math.floor((Date.now() - timerData.startTime) / 1000);
                    await updateTime(riderNumber, timerData.stageIndex, elapsedSeconds);
                    showMessage(`Time saved for Rider #${riderNumber}, Stage ${timerData.stageIndex + 1}`);
                }
            } catch (error) { console.error("Error stopping timer: ", error); showMessage('Failed to stop timer.', true);
            } finally { await deleteDoc(timerDocRef); }
        };

        const populateTimingDropdown = () => {
            if (!timingRiderInput || !Array.isArray(raceData.riders)) return;
            const currentSelection = timingRiderInput.value;
            timingRiderInput.innerHTML = '<option value="">Select Rider to Start</option>';
            raceData.riders.forEach(rider => {
                const option = document.createElement('option');
                option.value = rider.number;
                const categoryText = rider.category ? ` (${rider.category})` : '';
                option.textContent = `${rider.number} - ${rider.name}${categoryText}`;
                timingRiderInput.appendChild(option);
            });
            timingRiderInput.value = currentSelection;
        };

        const loadRace = () => {
            const raceId = raceIdInput.value.trim();
            if (!raceId) { showMessage('Please enter a race ID.', true); return; }
            raceInfoDiv.classList.add('hidden');
            raceTimerContainer.classList.remove('hidden');
            riderManagementSection.classList.remove('hidden');
            document.getElementById('currentRaceIdDisplay').textContent = `Race ID: ${raceId}`;
            setupRaceListener(raceId);
        };

        const createNewRace = () => {
            const stages = parseInt(stageCountInput.value, 10);
            if (isNaN(stages) || stages <= 0) { showMessage('Please enter a valid number of stages.', true); return; }
            const newRaceId = `race_${Date.now()}`;
            raceData.stages = stages;
            raceIdInput.value = newRaceId;
            loadRace();
        };

        const addRider = async (event) => {
            event.preventDefault();
            if (!currentRaceId) return showMessage('Please create or load a race first.', true);
            const riderNumber = parseInt(document.getElementById('riderNumber').value, 10);
            const riderName = document.getElementById('riderName').value.trim();
            const riderCategory = document.getElementById('riderCategory').value.trim();
            if (raceData.riders.length >= 100) return showMessage('Maximum 100 riders.', true);
            if (!riderNumber || !riderName) return showMessage('Please enter both rider number and name.', true);
            if (raceData.riders.some(r => r.number === riderNumber)) return showMessage('Rider number already exists.', true);
            const newRider = { number: riderNumber, name: riderName, category: riderCategory, times: Array(raceData.stages).fill(null), totalTime: 0, status: 'active' };
            const updatedRiders = [...raceData.riders, newRider];
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'enduro-timer-default';
            const raceDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'races', currentRaceId);
            await updateDoc(raceDocRef, { riders: updatedRiders });
            riderForm.reset();
            showMessage('Rider added successfully!');
        };
        
        const removeRider = async (riderNumber) => {
            if (!confirm(`Are you sure you want to remove Rider #${riderNumber}? This cannot be undone.`)) return;
            const updatedRiders = raceData.riders.filter(r => r.number !== riderNumber);
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'enduro-timer-default';
            const raceDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'races', currentRaceId);
            try {
                await updateDoc(raceDocRef, { riders: updatedRiders });
                showMessage(`Rider #${riderNumber} has been removed.`);
            } catch (error) {
                console.error("Error removing rider:", error);
                showMessage('Failed to remove rider.', true);
            }
        };

        const setRiderDnf = async (riderNumber, stageIndexToClear) => {
            const riderIndex = raceData.riders.findIndex(r => r.number === riderNumber);
            if (riderIndex !== -1) {
                let updatedRiders = JSON.parse(JSON.stringify(raceData.riders));
                updatedRiders[riderIndex].status = 'DNF';
                if (typeof stageIndexToClear === 'number') { updatedRiders[riderIndex].times[stageIndexToClear] = null; }
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'enduro-timer-default';
                const raceDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'races', currentRaceId);
                await updateDoc(raceDocRef, { riders: updatedRiders });
                showMessage(`Rider #${riderNumber} marked as DNF.`);
            }
        };

        const updateTime = async (riderNumber, stageIndex, seconds) => {
            const riderIndex = raceData.riders.findIndex(r => r.number === riderNumber);
            if (riderIndex !== -1) {
                let updatedRiders = JSON.parse(JSON.stringify(raceData.riders));
                updatedRiders[riderIndex].times[stageIndex] = seconds;
                if (updatedRiders[riderIndex].status === 'DNF') { updatedRiders[riderIndex].status = 'active'; }
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'enduro-timer-default';
                const raceDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'races', currentRaceId);
                await updateDoc(raceDocRef, { riders: updatedRiders });
            }
        };

        const parseTimeToSeconds = (timeString) => {
            if (!timeString) return null;
            const parts = timeString.split(':').map(Number);
            if (parts.some(isNaN)) return null;
            if (parts.length === 3) return parts[0] * 3600 + parts[1] * 60 + parts[2];
            if (parts.length === 2) return parts[0] * 60 + parts[1];
            if (parts.length === 1) return parts[0];
            return null;
        };

        const formatTime = (seconds) => {
            if (seconds === null || typeof seconds !== 'number') return 'N/A';
            const h = Math.floor(seconds / 3600), m = Math.floor((seconds % 3600) / 60), s = Math.floor(seconds % 60);
            const format = (val) => val.toString().padStart(2, '0');
            return `${format(h)}:${format(m)}:${format(s)}`;
        };

        const renderRaceData = () => {
            if (!ridersTableBody || !resultsTableBody || !Array.isArray(raceData.riders)) return;
            ridersTableBody.innerHTML = '';
            resultsTableBody.innerHTML = '';
            
            const ridersWithCalcs = raceData.riders.map(r => ({
                ...r,
                completedStages: r.times.filter(t => typeof t === 'number').length,
                runningTotal: r.times.reduce((sum, t) => sum + (t || 0), 0)
            }));

            const categories = [...new Set(ridersWithCalcs.map(r => r.category).filter(c => c))];
            const categoryRankings = {};
            categories.forEach(cat => {
                categoryRankings[cat] = ridersWithCalcs.filter(r => r.category === cat && r.status !== 'DNF').sort((a, b) => {
                    if (b.completedStages !== a.completedStages) return b.completedStages - a.completedStages;
                    return a.runningTotal - b.runningTotal;
                });
            });

            ridersWithCalcs.forEach((rider) => {
                const row = document.createElement('tr'); row.className = 'hover:bg-gray-50';
                row.innerHTML = `<td class="px-4 py-2 font-bold text-gray-700">${rider.number}</td><td class="px-4 py-2 text-gray-600">${rider.name}</td><td class="px-4 py-2 text-gray-500">${rider.category || ''}</td>`;
                for (let i = 0; i < raceData.stages; i++) {
                    const timeCell = document.createElement('td'); timeCell.className = 'px-4 py-2 text-gray-800 cursor-pointer hover:bg-yellow-200';
                    if (rider.status === 'DNF' && rider.times[i] === null) { timeCell.textContent = 'DNF'; timeCell.classList.add('text-red-600'); } else { timeCell.textContent = formatTime(rider.times[i]); }
                    timeCell.addEventListener('click', () => {
                        const newTimeStr = prompt(`Enter new time for ${rider.name} - Stage ${i + 1} (e.g., 5:30 or DNF):`, rider.status === 'DNF' ? 'DNF' : formatTime(rider.times[i]));
                        if (newTimeStr !== null) {
                            if (newTimeStr.trim().toUpperCase() === 'DNF') { setRiderDnf(rider.number, i); } else {
                                const newTimeInSeconds = parseTimeToSeconds(newTimeStr);
                                if (newTimeInSeconds !== null) { updateTime(rider.number, i, newTimeInSeconds); } else if (newTimeStr.trim() === '' || newTimeStr.toLowerCase() === 'n/a') { updateTime(rider.number, i, null); }
